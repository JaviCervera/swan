#ifndef SWAN_STR_H
#define SWAN_STR_H

#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <vector>

#ifdef _WIN32
#define realpath(N,R) _fullpath((R),(N),_MAX_PATH)
#endif

namespace swan {

  class str {
  public:
    template <typename T>
    static std::string fromnumber(T val) {
      std::ostringstream stream;
      stream << val;
      return stream.str();
    }

    template <typename T>
    static T tonumber(const std::string& str) {
      T number;
      std::istringstream stream(str);
      stream >> number;
      return number;
    }

    static std::string replace(const std::string& str, const std::string& find, const std::string& rep) {
      std::string strcopy = str;
      while ( strcopy.find(find) != std::string::npos ) {
        strcopy.replace(strcopy.find(find), find.length(), rep);
      }
      return strcopy;
    }

    static std::string stripext(const std::string& filename) {
      return filename.substr(0, filename.find('.'));
    }

    static std::string stripdir(const std::string& filename) {
      std::string filenameCopy = replace(filename, "\\", "/");
      return filenameCopy.substr(filenameCopy.rfind('/')+1, filenameCopy.length() - filenameCopy.rfind('/')-1);
    }

    static std::string extractext(const std::string& filename) {
      return filename.substr(filename.rfind('.')+1, filename.length() - filename.rfind('.')-1);
    }

    static std::string extractdir(const std::string& filename) {
      std::string filenameCopy = replace(filename, "\\", "/");
      return filenameCopy.substr(0, filenameCopy.rfind('/'));
    }

    static std::string read(const std::string& filename) {
      std::ifstream istream(filename.c_str(), std::ios_base::in | std::ios_base::binary);
      std::stringstream sstream;
      sstream << istream.rdbuf();
      istream.close();
      return sstream.str();
    }

    static void write(const std::string& str, const std::string& filename, bool append = true) {
      std::ofstream ostream(filename.c_str(), std::ios_base::out | std::ios_base::binary | (append ? std::ios_base::app : std::ios_base::trunc));
      ostream << str;
      ostream.close();
    }

    static std::vector<std::string> split(const std::string& str, char delim) {
      std::vector<std::string> elems;
      std::stringstream sstream(str);
      std::string item;
      while (std::getline(sstream, item, delim)) {
        elems.push_back(item);
      }
      return elems;
    }

    static std::string lset(const std::string& str, size_t length, char c) {
      std::string out = str;
      if ( out.length() > length ) {
        out.resize(length);
      } else if ( out.length() < length ) {
        out = std::string(length - out.length(), c) + out;
      }
      return out;
    }

    static std::string rset(const std::string& str, size_t length, char c) {
      std::string out = str;
      out.resize(length, c);
      return out;
    }
  protected:
    str() {}
  };
} // namespace swan

#endif // SWAN_STR_H
