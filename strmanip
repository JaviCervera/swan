#ifndef SWAN_STRMANIP_H
#define SWAN_STRMANIP_H

#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <vector>

#ifdef _WIN32
#define realpath(N,R) _fullpath((R),(N),_MAX_PATH)
#endif

namespace swan
{
  namespace strmanip
  {
    template <typename T>
    inline std::string fromnumber(T val)
    {
      std::ostringstream stream;
      stream << val;
      return stream.str();
    }

    template <typename T>
    inline T tonumber(const std::string& str)
    {
      T number;
      std::istringstream stream(str);
      stream >> number;
      return number;
    }

    inline std::string replace(const std::string& str, const std::string& find, const std::string& rep)
    {
      std::string strcopy = str;
      while ( strcopy.find(find) != std::string::npos )
      {
        strcopy.replace(strcopy.find(find), find.length(), rep);
      }
      return strcopy;
    }

    inline std::string stripext(const std::string& filename)
    {
      return filename.substr(0, filename.find('.'));
    }

    inline std::string stripdir(const std::string& filename)
    {
      std::string filenameCopy = replace(filename, "\\", "/");
      return filenameCopy.substr(filenameCopy.rfind('/')+1, filenameCopy.length() - filenameCopy.rfind('/')-1);
    }

    inline std::string extractext(const std::string& filename)
    {
      return filename.substr(filename.rfind('.')+1, filename.length() - filename.rfind('.')-1);
    }

    inline std::string extractdir(const std::string& filename)
    {
      std::string filenameCopy = replace(filename, "\\", "/");
      return filenameCopy.substr(0, filenameCopy.rfind('/'));
    }

    inline std::string read(const std::string& filename)
    {
      std::ifstream istream(filename.c_str(), std::ios_base::in | std::ios_base::binary);
      std::stringstream sstream;
      sstream << istream.rdbuf();
      istream.close();
      return sstream.str();
    }

    inline void write(const std::string& str, const std::string& filename, bool append = true)
    {
      std::ofstream ostream(filename.c_str(), std::ios_base::out | std::ios_base::binary | (append ? std::ios_base::app : std::ios_base::trunc));
      ostream << str;
      ostream.close();
    }

    inline std::vector<std::string> split(const std::string& str, char delim)
    {
      std::vector<std::string> elems;
      std::stringstream sstream(str);
      std::string item;
      while (std::getline(sstream, item, delim))
      {
        elems.push_back(item);
      }
      return elems;
    }

    inline std::string lset(const std::string& str, size_t length, char c)
    {
      std::string out = str;
      if ( out.length() > length )
      {
        out.resize(length);
      }
      else if ( out.length() < length )
      {
        out = std::string(length - out.length(), c) + out;
      }
      return out;
    }

    inline std::string rset(const std::string& str, size_t length, char c)
    {
      std::string out = str;
      out.resize(length, c);
      return out;
    }

#ifdef SWAN_TIME_H
    inline std::string parsetimeinfo(const time::timeinfo_t& ti, bool parsedate = true, bool parsetime = true)
    {
      std::string str;
      
      if ( parsedate )
      {
        str += lset(fromnumber(ti.year), 4, '0');
        str += "/";
        str += lset(fromnumber(ti.mon), 2, '0');
        str += "/";
        str +=  lset(fromnumber(ti.day), 2, '0');
      }

      if ( parsetime )
      {
        if ( str != "" ) str += " ";
        str += lset(fromnumber(ti.hour), 2, '0');
        str += ":";
        str += lset(fromnumber(ti.min), 2, '0');
        str += ":";
        str +=  lset(fromnumber(ti.sec), 2, '0');
      }

      return str;
    }   
#endif
  } // namespace strmanip
} // namespace swan

#endif // SWAN_STRMANIP_H

