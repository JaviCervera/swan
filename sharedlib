#ifndef SWAN_SHAREDLIB_H
#define SWAN_SHAREDLIB_H

#include <string>

#ifdef _WIN32
extern "C" void* __stdcall LoadLibraryA(const char*);
extern "C" void* __stdcall GetProcAddress(const void*, const char*);
extern "C" int __stdcall FreeLibrary(void*);
#else
#include <dlfcn.h>
#endif

namespace swan
{
  class sharedlib_t
  {
  public:
    sharedlib_t(const char* filename);
    ~sharedlib_t() { if ( handle ) platform_freelibrary(handle); }
    bool isopen() const { return handle != 0; }
    void* funcptr(const char* name) const { return platform_libraryfunction(handle, name); }
  private:
    void* handle;
  };

  inline sharedlib_t::sharedlib_t(const char* libname)
  {
#if defined(_WIN32)
    handle = LoadLibraryA((libname + std::string(".dll")).c_str());
#elif defined(__APPLE__)
    handle = dlopen((libname + std::string(".dylib")).c_str(), RTLD_LAZY);
#elif defined(__linux__)
    handle = dlopen((libname + std::string(".so")).c_str(), RTLD_LAZY);
#endif
  }

  inline sharedlib_t::~sharedlib_t()
  {
    if ( handle )
    {
#if defined(_WIN32)
      FreeLibrary(handle);
#else
      dlclose(handle);
#endif
    }
  }

  inline void* sharedlib_t::funcptr(void* lib, const char* funcname)
  {
    if ( handle )
    {
#if defined(_WIN32)
      return GetProcAddress(handle, funcname);
#else
      std::string str = funcname;
      size_t atpos = str.find('@');
      if ( atpos != std::string::npos ) str = str.substr(0, atpos);
      if ( str[0] == '_' ) str = str.substr(1, std::string::npos);
      return dlsym(handle, str.c_str());
#endif
    }
    else
    {
      return 0;
    }
  }

} // namespace swan

#endif // SWAN_SHAREDLIB_H

